package attackdns

	port type Port()
	port type Port1Data( int address)
	port type Port2Data( bool success, int address )
	port type Port2Data2( int address, float money )

	 /*
	  * connectors
	  */	
	connector type Estimator(Port p)
		define p
	end

	connector type UpdateCache( Port2Data ad, Port2Data cache)
		define ad cache
		on ad cache down {if (ad.success) then cache.address = ad.address; else cache.address = 77777; fi  }
	end

	connector type ExchangeAddress( Port1Data user, Port1Data cache)
		define user cache
		on user cache down { user.address = cache.address;}
	end

	connector type Connect(Port user, Port b_network, Port ad_network)
		define user b_network ad_network
	end

	connector type Transfer(Port2Data2 user, Port2Data2 b_network, Port2Data2 ad_network)
		define user b_network ad_network
		on user b_network ad_network down {if (user.address == ad_network.address) then ad_network.money =  user.money/10; else  b_network.money = user.money/10; fi user.money = user.money * 0.9;  }
	end

	atom type User()
		// Data variables
  		data int received_address // network address
  		data float money                // money amount

		// Instantiate clocks
		clock x unit nanosecond

		// Exported ports
  		port Port  wait()
		port Port done()
  		export port Port1Data  address(received_address)
		export port Port connect()
		export port Port2Data2 transfer (received_address, money)

		// Locations
  		place u0, u1, u2, u3, u4

		// Initial location declarations
		initial to u0 do { money = 1000; x = 0; received_address = 0;}

		// Transitions
  		on wait     from u0  to u0  
		delayable 
		do {x = 0;}

  		on address     from u0  to u1  
		delayable 
		do { x = 0; }

  		on wait     from u1  to u1  
		delayable 
		do { x = 0; }

  		on address     from u1  to u2  
		delayable 
		do {  x = 0; }

  		on connect     from u2  to u3  
		delayable 
		do {  x = 0; }


  		on transfer from u3  to u4  
		delayable 
		do {x = 0; }

  		on done from u4  to u4  
		delayable 
		do {x = 0;}
	end

	atom type Attacker()
		// Data variables
  		data int fake_address
		data bool success

		// Instantiate clocks
		clock y unit nanosecond

		// Exported ports
  		port Port  check_success()
		export port Port estimate()
		export port Port2Data update_cache(success, fake_address) 

		// Locations
  		place a0, a1, a2

		// Initial location declarations
		initial to a0 do {  success = false; y = 0; fake_address = 99999;}

		// Transitions
		@stochastic(dist="normal", clk=y, param="10.2")
		on estimate from a0 to a1
		delayable
		do {success = true; }
		
  		on update_cache   from a1  to a2  
		delayable 
		do {  success = false;}

  		on check_success   from a2  to a0  
		delayable 
		do { success = false; }
	end

	atom type DNSCache()
		// Data variables
  		data int send_address
		data bool attacked
		data bool use_crypto

		// Instantiate clocks
		clock cl unit nanosecond

		// Exported ports
		port Port  wait()
		export port Port estimate()	
		export port Port2Data update_cache (attacked, send_address) 
		export port Port1Data  address(send_address)

		// Locations
  		place c0, c1, c2

		// Initial location declarations
		initial to c0 do { send_address = 77777; attacked = false; cl = 0; use_crypto = false;}

		// Transitions
		@stochastic(dist="normal", clk=cl, param="1002")
		on estimate from c0 to c1
		delayable
		do {use_crypto = true; }

  		on update_cache     from c1 to c2  
		delayable 
		do { if(use_crypto) then  send_address = 77777; fi}
  		on wait     from c2 to c0  
		delayable 
		do { cl = 0; use_crypto = false; }

  		on address     from c2  to c2  
		delayable 
		do { cl = 0; use_crypto = false; }
	end

	atom type BitcoinNetwork()
		// Data variables
  		data int cur_address	// network address
		data bool adversary
		data float money

		// Instantiate clocks
		clock x unit nanosecond

		// Exported ports
  		port Port  wait()
  		export port Port  connect()
		export port Port2Data2  transfer(cur_address, money)

		// Locations
  		place bn0, bn1

		// Initial location declarations
		initial to bn0 do {cur_address = 77777; money = 0; adversary = false; x = 0;}

		// Transitions
  		on connect     from bn0  to bn0  
		delayable 
		do { x = 0;}

  		on transfer     from bn0  to bn1  
		delayable 
		do { x = 0; }

  		on wait     from bn1  to bn0  
		delayable 
		do { x = 0; }

	end

	atom type AttackerNetwork()
		// Data variables
  		data int cur_address// network address
		data bool adversary
		data float money

		// Instantiate clocks
		clock x unit nanosecond

		// Exported ports
  		port Port  wait()
  		export port Port  connect()
		export port Port2Data2  transfer(cur_address, money)

		// Locations
  		place an0, an1

		// Initial location declarations
		initial to an0 do { cur_address = 99999; money = 0; adversary = true; x = 0;}

		// Transitions
  		on connect     from an0  to an0  
		delayable 
		do { x = 0; }

  		on transfer     from an0  to an1  
		delayable 
		do { x = 0; }

  		on wait     from an1  to an0  
		delayable 
		do { x = 0; }
	end


	// Compound types definitions
	compound type Compound()
		component User user()
		component Attacker  attacker()
		component DNSCache cache()
		component BitcoinNetwork bit_network() 
		component AttackerNetwork attack_network()

		connector Estimator at_estimate1(attacker.estimate)
		connector Estimator cache_estimate1(cache.estimate)
		connector UpdateCache update1(attacker.update_cache, cache.update_cache)
		
		connector ExchangeAddress exchange1(user.address, cache.address)

		connector Connect connect(user.connect, bit_network.connect, attack_network.connect)

		connector Transfer transfer(user.transfer, bit_network.transfer, attack_network.transfer)

	end
end